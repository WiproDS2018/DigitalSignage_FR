// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var amqp10 = require("amqp10");
var machina = require("machina");
var amqp_message_1 = require("./amqp_message");
var azure_iot_common_1 = require("azure-iot-common");
var amqp_cbs_1 = require("./amqp_cbs");
var sender_link_1 = require("./sender_link");
var receiver_link_1 = require("./receiver_link");
var dbg = require("debug");
var async = require("async");
var debug = dbg('azure-iot-amqp-base:Amqp');
var _amqpClientError = 'client:errorReceived';
/**
 * @private
 * @class module:azure-iot-amqp-base.Amqp
 * @classdesc Basic AMQP functionality used by higher-level IoT Hub libraries.
 *            Usually you'll want to avoid using this class and instead rely on higher-level implementations
 *            of the AMQP transport (see [azure-iot-device-amqp.Amqp]{@link module:azure-iot-device-amqp.Amqp} for example).
 *
 * @param   {Boolean}   autoSettleMessages      Boolean indicating whether messages should be settled automatically or if the calling code will handle it.
 * @param   {String}    sdkVersionString        String identifying the type and version of the SDK used.
 */
var Amqp = /** @class */ (function () {
    /*Codes_SRS_NODE_COMMON_AMQP_16_001: [The Amqp constructor shall accept two parameters:
      A Boolean indicating whether the client should automatically settle messages:
          True if the messages should be settled automatically
          False if the caller intends to manually settle messages
          A string containing the version of the SDK used for telemetry purposes] */
    function Amqp(autoSettleMessages, sdkVersionString) {
        var _this = this;
        this._receivers = {};
        this._senders = {};
        var autoSettleMode = autoSettleMessages ? amqp10.Constants.receiverSettleMode.autoSettle : amqp10.Constants.receiverSettleMode.settleOnDisposition;
        // node-amqp10 has an automatic reconnection/link re-attach feature that is enabled by default.
        // In our case we want to control the reconnection flow ourselves, so we need to disable it.
        /*Codes_SRS_NODE_COMMON_AMQP_16_042: [The Amqp constructor shall create a new `amqp10.Client` instance and configure it to:
        - not reconnect on failure
        - not reattach sender and receiver links on failure
        - not reestablish sessions on failure]*/
        this._amqp = new amqp10.Client(amqp10.Policy.merge({
            session: {
                reestablish: {
                    retries: 0,
                    forever: false
                }
            },
            senderLink: {
                attach: {
                    properties: {
                        'com.microsoft:client-version': sdkVersionString
                    },
                    maxMessageSize: 0,
                },
                encoder: function (body) {
                    if (typeof body === 'string') {
                        return new Buffer(body, 'utf8');
                    }
                    else {
                        return body;
                    }
                },
                reattach: {
                    retries: 0,
                    forever: false
                }
            },
            receiverLink: {
                attach: {
                    properties: {
                        'com.microsoft:client-version': sdkVersionString
                    },
                    maxMessageSize: 0,
                    receiverSettleMode: autoSettleMode,
                },
                decoder: function (body) { return body; },
                reattach: {
                    retries: 0,
                    forever: false
                }
            },
            // reconnections will be handled at the client level, not the transport level.
            reconnect: {
                retries: 0,
                strategy: 'fibonacci',
                forever: false
            }
        }, amqp10.Policy.EventHub));
        var amqpErrorHandler = function (err) {
            debug('amqp10 client error: ' + err.toString());
            _this._fsm.handle('amqpError', err);
        };
        this._amqp.on('disconnected', function () {
            _this._fsm.handle('amqpDisconnected');
        });
        this._fsm = new machina.Fsm({
            namespace: 'amqp-base',
            initialState: 'disconnected',
            states: {
                disconnected: {
                    _onEnter: function (disconnectCallback, err, result) {
                        if (disconnectCallback) {
                            if (err) {
                                _this._safeCallback(disconnectCallback, err);
                            }
                            else {
                                _this._safeCallback(disconnectCallback, null, new azure_iot_common_1.results.Disconnected());
                            }
                        }
                        else if (_this._disconnectHandler) {
                            debug('calling upper layer disconnect handler');
                            _this._disconnectHandler(err);
                        }
                    },
                    amqpError: function (err) {
                        debug('received an error while disconnected: maybe a bug: ' + (!!err ? err.toString() : 'falsy error object.'));
                    },
                    amqpDisconnected: function () { return debug('ignoring disconnected event while disconnected'); },
                    connect: function (policyOverride, connectCallback) {
                        _this._fsm.transition('connecting', policyOverride, connectCallback);
                    },
                    disconnect: function (callback) { return callback(null, new azure_iot_common_1.results.Disconnected()); },
                    attachSenderLink: function (endpoint, linkOptions, callback) {
                        _this._fsm.handle('connect', null, function (err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                _this._fsm.handle('attachSenderLink', endpoint, linkOptions, callback);
                            }
                        });
                    },
                    attachReceiverLink: function (endpoint, linkOptions, callback) {
                        _this._fsm.handle('connect', null, function (err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                _this._fsm.handle('attachReceiverLink', endpoint, linkOptions, callback);
                            }
                        });
                    },
                    detachSenderLink: function (endpoint, callback) { return _this._safeCallback(callback); },
                    detachReceiverLink: function (endpoint, callback) { return _this._safeCallback(callback); },
                    initializeCBS: function (callback) {
                        _this._fsm.handle('connect', null, function (err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                _this._fsm.handle('initializeCBS', callback);
                            }
                        });
                    },
                    putToken: function (audience, token, callback) {
                        _this._fsm.handle('initializeCBS', function (err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                _this._fsm.handle('putToken', audience, token, callback);
                            }
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition('connected'); }
                },
                connecting: {
                    _onEnter: function (policyOverride, connectCallback) {
                        var connectError = null;
                        var connectErrorHandler = function (err) {
                            connectError = err;
                        };
                        _this._amqp.on(_amqpClientError, connectErrorHandler);
                        _this._amqp.connect(_this.uri, policyOverride)
                            .then(function (result) {
                            debug('AMQP transport connected.');
                            _this._amqp.on(_amqpClientError, amqpErrorHandler);
                            _this._amqp.removeListener(_amqpClientError, connectErrorHandler);
                            _this._fsm.transition('connected', connectCallback, result);
                            return null;
                        })
                            .catch(function (err) {
                            _this._amqp.removeListener(_amqpClientError, connectErrorHandler);
                            /*Codes_SRS_NODE_COMMON_AMQP_16_003: [The `connect` method shall call the `done` callback if the connection fails.] */
                            _this._fsm.transition('disconnected', connectCallback, connectError || err);
                        });
                    },
                    amqpError: function (err) { return _this._fsm.transition('disconnecting', null, err); },
                    amqpDisconnected: function () { return debug('ignoring disconnected event while connecting'); },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                connected: {
                    _onEnter: function (connectCallback, result) {
                        /*Codes_SRS_NODE_COMMON_AMQP_16_002: [The `connect` method shall establish a connection with the IoT hub instance and if given as argument call the `done` callback with a null error object in the case of success and a `results.Connected` object.]*/
                        _this._safeCallback(connectCallback, null, new azure_iot_common_1.results.Connected(result));
                    },
                    amqpError: function (err) { return _this._fsm.transition('disconnecting', null, err); },
                    amqpDisconnected: function () { return _this._fsm.transition('disconnected', undefined, new azure_iot_common_1.errors.NotConnectedError('amqp10: connection closed')); },
                    connect: function (policyOverride, callback) { return callback(null, new azure_iot_common_1.results.Connected()); },
                    disconnect: function (disconnectCallback) {
                        _this._fsm.transition('disconnecting', disconnectCallback);
                    },
                    initializeCBS: function (callback) {
                        _this._cbs = new amqp_cbs_1.ClaimsBasedSecurityAgent(_this._amqp);
                        _this._cbs.attach(callback);
                    },
                    putToken: function (audience, token, callback) {
                        _this._cbs.putToken(audience, token, callback);
                    },
                    send: function (message, endpoint, to, done) {
                        /*Codes_SRS_NODE_COMMON_AMQP_16_006: [The `send` method shall construct an AMQP message using information supplied by the caller, as follows:
                        The ‘to’ field of the message should be set to the ‘to’ argument.
                        The ‘body’ of the message should be built using the message argument.] */
                        debug('call to deprecated api \'azure-iot-amqp-base.Amqp.send\'. You should be using SenderLink.send instead');
                        var amqpMessage = amqp_message_1.AmqpMessage.fromMessage(message);
                        if (to !== undefined) {
                            amqpMessage.properties.to = to;
                        }
                        if (!_this._senders[endpoint]) {
                            _this._fsm.handle('attachSenderLink', endpoint, null, function (err) {
                                if (err) {
                                    debug('failed to attach the sender link: ' + err.toString());
                                    done(err);
                                }
                                else {
                                    _this._senders[endpoint].send(amqpMessage, done);
                                }
                            });
                        }
                        else {
                            _this._senders[endpoint].send(amqpMessage, done);
                        }
                    },
                    getReceiver: function (endpoint, done) {
                        /*Codes_SRS_NODE_COMMON_AMQP_16_010: [If a receiver for this endpoint doesn’t exist, the getReceiver method should create a new AmqpReceiver object and then call the done() method with the object that was just created as an argument.] */
                        if (!_this._receivers[endpoint]) {
                            _this._fsm.handle('attachReceiverLink', endpoint, null, function (err) {
                                if (err) {
                                    done(err);
                                }
                                else {
                                    done(null, _this._receivers[endpoint]);
                                }
                            });
                        }
                        else {
                            /*Codes_SRS_NODE_COMMON_AMQP_16_009: [If a receiver for this endpoint has already been created, the getReceiver method should call the done() method with the existing instance as an argument.] */
                            done(null, _this._receivers[endpoint]);
                        }
                    },
                    attachReceiverLink: function (endpoint, linkOptions, done) {
                        debug('creating receiver link for: ' + endpoint);
                        _this._receivers[endpoint] = new receiver_link_1.ReceiverLink(endpoint, linkOptions, _this._amqp);
                        var permanentErrorHandler = function (err) {
                            debug('receiver link error - removing it from cache: ' + endpoint + ': ' + err.toString());
                            delete (_this._receivers[endpoint]);
                        };
                        var operationErrorHandler = function (err) {
                            debug('calling attachReceiverLink callback with error: ' + err.toString());
                            done(err);
                        };
                        _this._receivers[endpoint].on('error', permanentErrorHandler);
                        _this._receivers[endpoint].on('error', operationErrorHandler);
                        _this._receivers[endpoint].attach(function (err) {
                            if (err) {
                                debug('failed to attach receiver link: ' + endpoint + ': ' + err.toString());
                                permanentErrorHandler(err);
                                operationErrorHandler(err);
                            }
                            else {
                                _this._receivers[endpoint].removeListener('error', operationErrorHandler);
                                debug('receiver link attached: ' + endpoint);
                                done(null, _this._receivers[endpoint]);
                            }
                        });
                    },
                    attachSenderLink: function (endpoint, linkOptions, done) {
                        debug('creating sender link for: ' + endpoint);
                        var senderFsm = new sender_link_1.SenderLink(endpoint, linkOptions, _this._amqp);
                        _this._senders[endpoint] = senderFsm;
                        var permanentErrorHandler = function (err) {
                            debug('sender link error while attaching: ' + endpoint + ': ' + err.toString());
                            delete (_this._senders[endpoint]);
                        };
                        var operationErrorHandler = function (err) {
                            debug('calling attachSenderLink callback with error: ' + err.toString());
                            done(err);
                        };
                        _this._senders[endpoint].on('error', permanentErrorHandler);
                        _this._senders[endpoint].on('error', operationErrorHandler);
                        debug('attaching sender link for: ' + endpoint);
                        _this._senders[endpoint].attach(function (err) {
                            if (err) {
                                permanentErrorHandler(err);
                                operationErrorHandler(err);
                            }
                            else {
                                _this._senders[endpoint].removeListener('error', operationErrorHandler);
                                debug('sender link attached: ' + endpoint);
                                done(null, _this._senders[endpoint]);
                            }
                        });
                    },
                    detachReceiverLink: function (endpoint, detachCallback) {
                        if (!_this._receivers[endpoint]) {
                            _this._safeCallback(detachCallback);
                        }
                        else {
                            _this._detachLink(_this._receivers[endpoint], function (err) {
                                delete (_this._receivers[endpoint]);
                                _this._safeCallback(detachCallback, err);
                            });
                        }
                    },
                    detachSenderLink: function (endpoint, detachCallback) {
                        _this._detachLink(_this._senders[endpoint], function (err) {
                            delete (_this._senders[endpoint]);
                            _this._safeCallback(detachCallback, err);
                        });
                    }
                },
                disconnecting: {
                    _onEnter: function (disconnectCallback, err) {
                        var disconnect = function (callback) {
                            if (err) {
                                callback();
                            }
                            else {
                                /*Codes_SRS_NODE_COMMON_AMQP_16_004: [The disconnect method shall call the done callback when the application/service has been successfully disconnected from the service] */
                                _this._amqp.disconnect().then(function () {
                                    debug('amqp10 client cleanly disconnected');
                                    callback();
                                    return null;
                                }).catch(function (err) {
                                    debug('amqp10 failed to cleanly disconnect: ' + err.toString());
                                    callback(err);
                                });
                            }
                        };
                        var detachLink = function (link, callback) {
                            if (!link) {
                                return callback();
                            }
                            if (err) {
                                debug('forceDetaching link');
                                link.forceDetach(err);
                                callback();
                            }
                            else {
                                debug('cleanly detaching link');
                                link.detach(callback);
                            }
                        };
                        detachLink(_this._cbs, function () {
                            var remainingLinks = [];
                            for (var senderEndpoint in _this._senders) {
                                if (_this._senders.hasOwnProperty(senderEndpoint)) {
                                    remainingLinks.push(_this._senders[senderEndpoint]);
                                    delete _this._senders[senderEndpoint];
                                }
                            }
                            for (var receiverEndpoint in _this._receivers) {
                                if (_this._receivers.hasOwnProperty(receiverEndpoint)) {
                                    remainingLinks.push(_this._receivers[receiverEndpoint]);
                                    delete _this._receivers[receiverEndpoint];
                                }
                            }
                            /*Codes_SRS_NODE_COMMON_AMQP_16_034: [The `disconnect` method shall detach all open links before disconnecting the underlying AMQP client.]*/
                            async.each(remainingLinks, detachLink, function () {
                                disconnect(function (disconnectError) {
                                    var finalError = err || disconnectError;
                                    _this._amqp.removeListener(_amqpClientError, amqpErrorHandler);
                                    _this._fsm.transition('disconnected', disconnectCallback, finalError);
                                });
                            });
                        });
                    },
                    amqpError: function (err) { return debug('ignoring error event while disconnecting: ' + (!!err) ? err.toString() : 'falsy error object'); },
                    amqpDisconnected: function () { return debug('ignoring disconnected event while disconnecting'); },
                    '*': function () { return _this._fsm.deferUntilTransition('disconnected'); }
                }
            }
        });
        this._fsm.on('transition', function (transition) {
            debug(transition.fromState + ' -> ' + transition.toState + ' (action:' + transition.action + ')');
        });
    }
    /**
     * @method             module:azure-iot-amqp-base.Amqp#connect
     * @description        Establishes a connection with the IoT Hub instance.
     * @param {String}     uri           The uri to connect with.
     * @param {Object}     sslOptions    SSL certificate options.
     * @param {Function}   done          Callback called when the connection is established or if an error happened.
     */
    Amqp.prototype.connect = function (uri, sslOptions, done) {
        this._setUriAndSocketTransport(uri);
        var policyOverride = {
            options: {
                sslOptions: sslOptions
            }
        };
        this._fsm.handle('connect', policyOverride, done);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#connectWithCustomSasl
     * @description        Establishes a connection with an Amqp service using a custom SASL mechanism
     * @param {String}     uri           The uri to connect with.
     * @param {String}     mechanismName The name of the SASL mechanism
     * @param {Object}     mechanism     SASL mechanism object
     * @param {Function}   done          Callback called when the connection is established or if an error happened.
     */
    Amqp.prototype.connectWithCustomSasl = function (uri, mechanismName, mechanism, done) {
        this._setUriAndSocketTransport(uri);
        var policyOverride = {
            saslMechanism: mechanismName
        };
        this._amqp.registerSaslMechanism(mechanismName, mechanism);
        this._fsm.handle('connect', policyOverride, done);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#setDisconnectCallback
     * @description        Sets the callback that should be called in case of disconnection.
     * @param {Function}   disconnectCallback   Called when the connection disconnected.
     */
    Amqp.prototype.setDisconnectHandler = function (disconnectCallback) {
        this._disconnectHandler = disconnectCallback;
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#disconnect
     * @description        Disconnects the link to the IoT Hub instance.
     * @param {Function}   done   Called when disconnected of if an error happened.
     */
    Amqp.prototype.disconnect = function (done) {
        this._fsm.handle('disconnect', done);
    };
    /**
     * @deprecated         Use attachSenderLink and the SenderLink.send() method instead
     * @method             module:azure-iot-amqp-base.Amqp#send
     * @description        Sends a message to the IoT Hub instance.
     *
     * @param {Message}   message   The message to send.
     * @param {string}    endpoint  The endpoint to use when sending the message.
     * @param {string}    to        The destination of the message.
     * @param {Function}  done      Called when the message is sent or if an error happened.
     */
    Amqp.prototype.send = function (message, endpoint, to, done) {
        this._fsm.handle('send', message, endpoint, to, done);
    };
    /**
     * @deprecated         use attachReceiverLink() instead.
     * @method             module:azure-iot-amqp-base.Amqp#getReceiver
     * @description        Gets the {@linkcode AmqpReceiver} object that can be used to receive messages from the IoT Hub instance and accept/reject/release them.
     *
     * @param {string}    endpoint  Endpoint used for the receiving link.
     * @param {Function}  done      Callback used to return the {@linkcode AmqpReceiver} object.
     */
    Amqp.prototype.getReceiver = function (endpoint, done) {
        this._fsm.handle('getReceiver', endpoint, done);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#attachReceiverLink
     * @description        Creates and attaches an AMQP receiver link for the specified endpoint.
     *
     * @param {string}    endpoint    Endpoint used for the receiver link.
     * @param {Object}    linkOptions Configuration options to be merged with the AMQP10 policies for the link..
     * @param {Function}  done        Callback used to return the link object or an Error.
     */
    Amqp.prototype.attachReceiverLink = function (endpoint, linkOptions, done) {
        /*Codes_SRS_NODE_COMMON_AMQP_16_017: [The `attachReceiverLink` method shall throw a ReferenceError if the `endpoint` argument is falsy.]*/
        if (!endpoint) {
            throw new ReferenceError('endpoint cannot be \'' + endpoint + '\'');
        }
        this._fsm.handle('attachReceiverLink', endpoint, linkOptions, done);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#attachSenderLink
     * @description        Creates and attaches an AMQP sender link for the specified endpoint.
     *
     * @param {string}    endpoint    Endpoint used for the sender link.
     * @param {Object}    linkOptions Configuration options to be merged with the AMQP10 policies for the link..
     * @param {Function}  done        Callback used to return the link object or an Error.
     */
    Amqp.prototype.attachSenderLink = function (endpoint, linkOptions, done) {
        /*Codes_SRS_NODE_COMMON_AMQP_16_012: [The `attachSenderLink` method shall throw a ReferenceError if the `endpoint` argument is falsy.]*/
        if (!endpoint) {
            throw new ReferenceError('endpoint cannot be \'' + endpoint + '\'');
        }
        this._fsm.handle('attachSenderLink', endpoint, linkOptions, done);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#detachReceiverLink
     * @description        Detaches an AMQP receiver link for the specified endpoint if it exists.
     *
     * @param {string}    endpoint  Endpoint used to identify which link should be detached.
     * @param {Function}  done      Callback used to signal success or failure of the detach operation.
     */
    Amqp.prototype.detachReceiverLink = function (endpoint, detachCallback) {
        /*Codes_SRS_NODE_COMMON_AMQP_16_027: [The `detachReceiverLink` method shall throw a ReferenceError if the `endpoint` argument is falsy.]*/
        if (!endpoint) {
            throw new ReferenceError('endpoint cannot be \'' + endpoint + '\'');
        }
        this._fsm.handle('detachReceiverLink', endpoint, detachCallback);
    };
    /**
     * @method             module:azure-iot-amqp-base.Amqp#detachSenderLink
     * @description        Detaches an AMQP sender link for the specified endpoint if it exists.
     *
     * @param {string}    endpoint  Endpoint used to identify which link should be detached.
     * @param {Function}  done      Callback used to signal success or failure of the detach operation.
     */
    Amqp.prototype.detachSenderLink = function (endpoint, detachCallback) {
        /*Codes_SRS_NODE_COMMON_AMQP_16_022: [The `detachSenderLink` method shall throw a ReferenceError if the `endpoint` argument is falsy.]*/
        if (!endpoint) {
            throw new ReferenceError('endpoint cannot be \'' + endpoint + '\'');
        }
        this._fsm.handle('detachSenderLink', endpoint, detachCallback);
    };
    Amqp.prototype.initializeCBS = function (callback) {
        this._fsm.handle('initializeCBS', callback);
    };
    Amqp.prototype.putToken = function (audience, token, callback) {
        this._fsm.handle('putToken', audience, token, callback);
    };
    Amqp.prototype._detachLink = function (link, detachCallback) {
        var _this = this;
        if (!link) {
            /*Codes_SRS_NODE_COMMON_AMQP_16_030: [The `detachReceiverLink` method shall call the `done` callback with no arguments if the link for this endpoint doesn't exist.]*/
            /*Codes_SRS_NODE_COMMON_AMQP_16_025: [The `detachSenderLink` method shall call the `done` callback with no arguments if the link for this endpoint doesn't exist.]*/
            this._safeCallback(detachCallback);
        }
        else {
            /*Codes_SRS_NODE_COMMON_AMQP_16_028: [The `detachReceiverLink` method shall call detach on the link object corresponding to the endpoint passed as argument.]*/
            /*Codes_SRS_NODE_COMMON_AMQP_16_023: [The `detachSenderLink` method shall call detach on the link object corresponding to the endpoint passed as argument.]*/
            link.detach(function () {
                /*Codes_SRS_NODE_COMMON_AMQP_16_029: [The `detachReceiverLink` method shall call the `done` callback with no arguments if detaching the link succeeded.]*/
                /*Codes_SRS_NODE_COMMON_AMQP_16_024: [The `detachSenderLink` method shall call the `done` callback with no arguments if detaching the link succeeded.]*/
                _this._safeCallback(detachCallback);
            });
        }
    };
    /*Codes_SRS_NODE_COMMON_AMQP_16_011: [All methods should treat the `done` callback argument as optional and not throw if it is not passed as argument.]*/
    Amqp.prototype._safeCallback = function (callback, error, result) {
        if (callback) {
            process.nextTick(function () { return callback(error, result); });
        }
    };
    Amqp.prototype._setUriAndSocketTransport = function (uri) {
        /*Codes_SRS_NODE_COMMON_AMQP_06_002: [The `connect` method shall throw a ReferenceError if the uri parameter has not been supplied.] */
        if (!uri)
            throw new ReferenceError('The uri parameter can not be \'' + uri + '\'');
        this.uri = uri;
        if (this.uri.substring(0, 3) === 'wss') {
            var wsTransport = require('amqp10-transport-ws');
            wsTransport.register(amqp10.TransportProvider);
        }
    };
    return Amqp;
}());
exports.Amqp = Amqp;
//# sourceMappingURL=amqp.js.map